
**Concepts**

Callback 




**INTERVIEW QUESTIONS**




**-What is Node.js? What is it used for?**

Node.js is a run-time JavaScript environment built on top of Chrome’s V8 engine. 
It uses an event-driven, non-blocking I/O model. It is lightweight and so efficient. 
Node.js has a package ecosystem called npm.
Node.js can be used to build different types of applications such as web application, real-time chat application, REST API server etc.

**-What is Event-driven programming?**

Event-driven programming is building our application based on and respond to events. When an event occurs, like click or keypress, we are running a callback function which is registered to the element for that event.

**-What is Event loop in Node.js work? And How does it work?**

The Event loop handles all async callbacks. Node.js (or JavaScript) is a single-threaded, event-driven language. This means that we can attach listeners to events, and when a said event fires, the listener executes the callback we provided.
Whenever we are call setTimeout, http.get and fs.readFile, Node.js runs this operations and further continue to run other code without waiting for the output. When the operation is finished, it receives the output and runs our callback function.
So all the callback functions are queued in an loop, and will run one-by-one when the response has been received.

**-What is REPL in Node.js?**

REPL means Read-Eval-Print-Loop. It is a virtual environment that comes with Node.js. We can quickly test our JavaScript code in the Node.js REPL environment.
To launch the REPL in Node.js, just open the command prompt and type node. It will change the prompt to > in Windows and MAC.
Now we can type and run our JavaScript easily. For example, if we type 10 + 20, it will print 30 in the next line.

**-What is the difference between synchronous and asynchronous in node js?**

In synchronous functions, statements complete before the next statement is run. In this case, the program is evaluated exactly in order of the statements and execution of the program is paused if one of the statements take a very long time.

Asynchronous functions usually accept a callback as a parameter and execution continue on the next line immediately after the asynchronous function is invoked. The callback is only invoked when the asynchronous operation is complete and the call stack is empty. Heavy duty operations such as loading data from a web server or querying a database should be done asynchronously so that the main thread can continue executing other operations instead of blocking until that long operation to complete (in the case of browsers, the UI will freeze).

// This function is synchronous
```
function log(arg) {
    console.log(arg)
}

log(1);

// This function is asynchronous
setTimeout(() => {
    console.log(2)
}, 0);

log(3)

```
**-What is Tracing in Node.js?**

Tracing provides a mechanism to collect tracing information generated by V8, Node core and userspace code in a log file. Tracing can be enabled by passing the --trace-events-enabled flag when starting a Node.js application.

**-How will you debug an application in Node.js?**

Node.js includes a debugging utility called debugger. To enable it start the Node.js with the debug argument followed by the path to the script to debug.
Inserting the statement debugger; into the source code of a script will enable a breakpoint at that position in the code

**-Difference between setImmediate() vs setTimeout()**

setImmediate() and setTimeout() are similar, but behave in different ways depending on when they are called.
setImmediate() is designed to execute a script once the current poll (event loop) phase completes.
setTimeout() schedules a script to be run after a minimum threshold in ms has elapsed.

**-What is package.json? What is it used for?**

This file holds various metadata information about the project. This file is used to give information to npm that allows it to identify the project as well as handle the project's dependencies.

Some of the fields are: name, name, description, author and dependencies.
When someone installs our project through npm, all the dependencies listed will be installed as well. Additionally, if someone runs npm install in the root directory of our project, it will install all the dependencies to ./node_modules directory.

**-What is libuv?**

Some of the features of libuv are:

Full-featured event loop backed by epoll, kqueue, IOCP, event ports.
Asynchronous TCP and UDP sockets
Asynchronous file and file system operations
Child processes
File system events

**-What are some of the most popular modules of Node.js?**

express
async
browserify
socket.io
bower
gulp
grunt

**-What is EventEmitter in Node.js?**

All objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object.

When the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously.

**-What is the difference between readFile vs createReadStream in Node.js?**

readFile — is for asynchronously reads the entire contents of a file. It will read the file completely into memory before making it available to the User. readFileSync is synchronous version of readFile.

createReadStream — It will read the file in chunks of the default size 64 kb which is specified before hand.

**-What is the use of Timers is Node.js?**

The Timers module in Node.js contains functions that execute code after a set period of time. Timers do not need to be imported via require(), since all the methods are available globally to emulate the browser JavaScript API.

Node.js Timer provides setTimeout(), setImmediate() and setInterval.

**-What are the security mechanisms available in Node.js?**

Authentication — Authentication is one of the primary security stages at which user is identified as permitted to access the application at all. Authentication verifies the user’s identity through one or several checks.

Error Handling — Usually, the error message contains the explanation of what’s actually gone wrong for the user to understand the reason. At the same time, when the error is related to the application code syntax, it can be set to display the entire log content on the frontend.

Request Validation — Another aspect which has to be considered, while building a secure Node.js application, is a validation of requests or, in other words, a check of the incoming data for possible inconsistencies.

**-Where can we use node.js?**

Node.js can be used for the following purposes
a) Web applications ( especially real-time web apps )
b) Network applications
c) Distributed systems
d) General purpose applications

**-How node.js works?**

Node.js works on a v8 environment, it is a virtual machine that utilizes JavaScript as its scripting language and achieves high output via non-blocking I/O and single-threaded event loop.

**-Explain non-blocking I/O ?**

The term non-blocking is used in many different ways and contexts. In this post we were focusing on non-blocking I/O which refers to threads not waiting for I/O operations to finish. However sometimes people refer to APIs as non-blocking only because they do not block the current thread.

**-Explain blocking I/O ?**

When javascript execution in Node.js process (each program is a process) has to wait until a non-javascript operation completes is called blocking.

**-Explain Multi-Threaded Request-Response ?**

Client sends request to the server, then server do some processing based on clients request, prepare response and send it back to the client.

This model uses HTTP protocol. As HTTP is a Stateless Protocol, this Request/Response model is also Stateless Model. So we can call this as Request/Response Stateless Model.

Request/Response Model Processing Steps:

* Clients Send request to Web Server.
* Web Server internally maintains a Limited Thread pool to provide services to the Client Requests.
* Web Server is in infinite Loop and waiting for Client Incoming Requests
* Web Server receives those requests.
* Web Server pickup one Client Request
* Pickup one Thread from Thread pool
* Assign this Thread to Client Request
* This Thread will take care of reading Client request, processing Client request, performing any Blocking IO Operations (if required) and preparing Response
* This Thread sends prepared response back to the Web Server
* Web Server in-turn sends this response to the respective Client.

**-Explain Stateless Model ?**

A client program makes a request to an application server, which sends data back to the client. The server treats all client connections equally and saves no information from prior requests or sessions. A website that serves up a simple static web page is a good example of the stateless model.

**-Single Threaded Event Loop Model ?**

Single Threaded Event Loop Model Processing Steps:

* Clients Send request to Web Server.
* Node JS Web Server internally maintains a Limited Thread pool to provide services to the Client Requests.
* Node JS Web Server receives those requests and places them into a Queue. It is known as “Event Queue”.
* Node JS Web Server internally has a Component, known as “Event Loop”. Why it got this name is that it uses indefinite loop to receive requests and process them. (See some Java Pseudo code to understand this below).
* Event Loop uses Single Thread only. It is main heart of Node JS Platform Processing Model.
* Even Loop checks any Client Request is placed in Event Queue. If no, then wait for incoming requests for indefinitely.
* If yes, then pick up one Client Request from Event Queue
* Starts process that Client Request
* If that Client Request Does Not requires any Blocking IO Operations, then process everything, prepare response and send it back to client.
* If that Client Request requires some Blocking IO Operations like interacting with Database, File System, External Services then it will follow different approach
* Checks Threads availability from Internal Thread Pool
* Picks up one Thread and assign this Client Request to that thread.
* That Thread is responsible for taking that request, process it, perform Blocking IO operations, prepare response and send it back to the Event Loop
* Event Loop in turn, sends that Response to the respective Client.

**-What are the two types of API functions in Node.js?**

* Asynchronous, non-blocking functions
* Synchronous, blocking functions

**-What is the advantage of using node.js?**

* It provides an easy way to build scalable network programs
* Generally fast
* Great concurrency
* Asynchronous everything
* Almost never blocks

**-What is the difference between Node.js vs Ajax?**

The difference between Node.js and Ajax is that Ajax (short for Asynchronous Javascript and XML) is a client-side technology, often used for updating the contents of the page without refreshing it. While,Node.js is Server Side Javascript, used for developing server software. Node.js does not execute in the browser but by the server.

**-What are the pros and cons of Node.js?**

Pros:
a) If your application does not have any CPU intensive computation, you can build it in the JavaScript top to bottom, even down to the database level if you use JSON storage object DB like MongoDB.
b) Crawlers receive a full-rendered HTML response, which is far more SEO friendly rather than a single page application or a websockets app run on top of Node.js.

Cons:
a) Any intensive CPU computation will block node.js responsiveness, so a threaded platform is a better approach.
b) Using a relational database with Node.js is considered less favorable

**-What are the benefits of using Node.js?**

* Asynchronous and Event Driven - All APIs of Node.js library are asynchronous that is non-blocking. It essentially means a Node.js based server never waits for a API to return data. Server moves to next API after calling it and a notification mechanism of Events of Node.js helps server to get response from the previous API call.

* Very Fast - Being built on Google Chrome's V8 JavaScript Engine, Node.js library is very fast in code execution.

* Single Threaded but highly Scalable - Node.js uses a single threaded model with event looping. Event mechanism helps server to respond in a non-blocking ways and makes server highly scalable as opposed to traditional servers which create limited threads to handle requests. Node.js uses a single threaded program and same program can services much larger number of requests than traditional server like Apache HTTP Server.

* No Buffering - Node.js applications never buffer any data. These applications simply output the data in chunks.

**-What is libuv?**

libuv is a C library that is used to abstract non-blocking I/O operations to a consistent interface across all supported platforms. It provides mechanisms to handle file system, DNS, network, child processes, pipes, signal handling, polling and streaming. It also includes a thread pool for offloading work for some things that can't be done asynchronously at the operating system level.

**-How does Node.js handle child threads?**

Node.js, in its essence, is a single thread process. It does not expose child threads and thread management methods to the developer. Technically, Node.js does spawn child threads for certain tasks such as asynchronous I/O, but these run behind the scenes and do not execute any application JavaScript code, nor block the main event loop.

If threading support is desired in a Node.js application, there are tools available to enable it, such as the ChildProcess module.

**-Rewrite promise-based Node.js applications to Async/Await ?**

```
function asyncTask() {
    return functionA()
        .then((valueA) => functionB(valueA))
        .then((valueB) => functionC(valueB))
        .then((valueC) => functionD(valueC))
        .catch((err) => logger.error(err))
}

```

```
async function asyncTask() {
    try {
        const valueA = await functionA()
        const valueB = await functionB(valueA)
        const valueC = await functionC(valueB)
        return await functionD(valueC)
    } catch (err) {
        logger.error(err)
    }
}
```

**-What's the Event Loop?**

![Image of Event Loop](https://i.stack.imgur.com/Lbs9z.png)

**-When should we use Node.js?**

Node.js is well suited for applications that have

a lot of concurrent connections and
each request only needs very few CPU cycles
because the event loop (with all the other clients) is blocked during execution of a function. Node.js is best suited for real-time applications:

* online games,
* collaboration tools,
* chat rooms,
* API's
* 
or anything where what one user does with the application needs to be seen by other users immediately, without a page refresh.

**-How do you convert an existing callback API to promises?**

```
function divisionAPI (number, divider, successCallback, errorCallback) {
    if (divider == 0) {
        return errorCallback( new Error("Division by zero") )
    }
    successCallback( number / divider )
}
```

```
function divisionAPI(number, divider) {
    return new Promise(function(fulfilled, rejected) {
        if (divider == 0) {
            return rejected(new Error("Division by zero"))
        }
        fulfilled(number / divider)
    })
}

// Promise can be used with together async\await in ES7 to make the program flow wait for a fullfiled result
async function foo() {
    var result = await divisionAPI(1, 2); // awaits for a fulfilled result!
    console.log(result);
}

// Another usage with the same code by using .then() method
divisionAPI(1, 2).then(function(result) {
    console.log(result)
})
```

**-How would you handle errors for async code in Node.js?**

```
doWork()
 .then(doWork)
 .then(doOtherWork)
 .then((result) => doWork)
 .catch((error) => {throw error;})
 .then(verify);
```

```
async function check(req, res) {
    try {
        const a = await someOtherFunction();
        const b = await somethingElseFunction();
        res.send("result")
    } catch (error) {
        res.send(error.stack);
    }
}
```

